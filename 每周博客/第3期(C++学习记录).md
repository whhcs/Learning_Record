C++的类可以分为带指针和不带指针两种。带指针数据成员的类，需要自己实现big three：拷贝构造函数、拷贝赋值函数、析构函数。

如果对于带指针的class，我们不自己写big three，编译器也会默认给我们一套。然而带指针的类如果依赖编译器提供的默认实现，会给我们带来资源的释放、深拷贝和浅拷贝的问题。

&nbsp;

@[TOC](目录)



## 拷贝赋值函数

```C++
inline String& String::operator=(const String& str)
{
	if (this == &str)     //检测自我赋值
		return *this;

	delete[] m_data;
	m_data = new char[strlen(str.m_data) + 1];
	strcpy(m_data, str.m_data);
	return *this;
}
```

在重载`=`运算符时，一定要主要检查是否自我赋值，原因如下：

![](https://img-blog.csdnimg.cn/img_convert/70a4b9cbdfc95c34971c151cd56e2903.png)
&nbsp;

## 拷贝构造函数

```C++
inline String::String(const char* cstr = 0)
{
	if (cstr)
	{
		m_data = new char(strlen(cstr) + 1);
		strcpy(m_data, cstr);
	}
	else
	{
		m_data = new char[1];
		*m_data = '\0';
	}
}
```
&nbsp;

## 析构函数

```C++
inline String::~String()
{
	delete[]m_data;
}
```

如果class里面带有指针数据成员，那么大多数都会涉及到内存的动态分配，析构函数必须负责在对象生命期结束时释放掉该对象申请来的内存，否则会造成内存泄漏。而使用编译器默认提供的析构函数无法释放动态生成的对象，导致内存泄漏，所以我们必须自己实现析构函数。

&nbsp;

## 深拷贝与浅拷贝

假如我们不自己编写拷贝构造函数和拷贝赋值函数，那么将使用编译器默认生成的拷贝构造函数和拷贝赋值函数。

编译器提供的默认实现是对类的内存进行按位的拷贝，即浅拷贝。它只是将对象内存上的每一个bit复制到另一个对象上去，来看下面这个例子：

![图片](https://img-blog.csdnimg.cn/img_convert/b0e6d821e7270c0e4569df31d9254d62.png)

若执行`b = a;`

浅拷贝体现为：

![图片](https://img-blog.csdnimg.cn/img_convert/2a6dca654c3b009d3fe635c36a60e2cc.png)

存储`World\0`的内存没有指针所指向，已经成了一块无法利用的内存，从而发生了内存泄漏。

不仅如此，如果此时对象`a`生命期结束，调用析构函数，存储`Hello\0`的内存块被释放，此时`b.m_data`成了一个野指针。如果再调用b的析构函数，会导致堆区内存重复释放。

而使用上面的拷贝赋值函数进行深拷贝，则不会又上述问题。同样执行`a = b;`，执行过程如下：

![图片](https://img-blog.csdnimg.cn/img_convert/3e0d1cdabc28b4320cf55a0f694e2946.png)

![图片](https://img-blog.csdnimg.cn/img_convert/d1336c96b612bd49139c27564e1d583e.png)

![图片](https://img-blog.csdnimg.cn/img_convert/597f82cb9666c7d347652652c5118360.png)

同样的，上面的拷贝构造函数也是一个深拷贝的过程。

&nbsp;

## **static与类**

- **不和对象直接相关的数据，声明为static**
  - 所有对象共享同一份数据
  &nbsp;
- **static成员函数没有this指针**
  - static成员函数与普通函数一样，都是只有一份函数的副本，存储在进程的代码段上。不一样的是，static成员函数没有`this指针`，所以它不能够调用普通的成员变量，只能调用static成员变量。
  - 普通成员函数的调用需要通过对象来调用，编译器会把对象取地址，作为this指针的实参传递给成员函数```obj.func() ---> class :: fun(&obj);```
  - 而static成员函数既可以通过对象来调用，又可以通过类名称来调用。
  &nbsp;
- **成员变量需要在类内声明，类外定义**

```c++
class A
{
    private:
        static int a; //①
}
int A::a = 10;  //②
```

注意①是声明，②才是定义，定义为变量分配了内存。
&nbsp;

- **static与类的一些小应用**

这些可以用来应付一下面试，在实现单例模式的时候，static成员函数与static成员变量得到了使用，下面是一种称为”饿汉式“的单例模式的实现：

```c++
class A
{
        public:
            static A& getInstance();
            setup(){...};
        private:
            A();
            A(const A & rhs);
            static A a;
}
```

这里把class A的构造函数都设置为私有，不允许用户代码创建对象。要获取对象实例需要通过接口`getInstance`。”饿汉式“缺点在于无论有没有代码需要`a`，`a`都被创建出来。下面是改进的单例模式，称为”懒汉式“：

```c++
class A
{
    public:
        static  A& getInstance();
        setup(){....};
    private:
        A();
        A(const A& rsh);
        ...
};
A& A::getInstance()
{
        static A a;
        return a;
}
```

“懒汉式”只有在真正需要`a`时，调用`getInstance`才创建出唯一实例。这可以看成一个具有拖延症的单例模式，不到最后关头不干活。很多设计都体现了这种拖延的思想，比如string的写时复制，真正需要的时候才分配内存给string对象管理的字符串。
&nbsp;
## 参考

CPP前沿开发

侯捷C++视频
