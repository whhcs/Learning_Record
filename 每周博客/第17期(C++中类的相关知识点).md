@[TOC](目录)

# C++中类的相关知识点

## 总述

类是一种自定义的数据类型。

在设计一个类的时候要多角度考虑，这里列举几点：

1. 如何理顺在设计一个类的时候这个类里的数据存储布局，有哪些必要的成员变量和成员函数要定义和实现。
2. 站在使用者的角度考虑，需要给使用者提供哪些可以访问的接口，而哪些接口不对外开放，只供类内的其他成员函数使用。
3. 在设计一个父类供子类继承的时候，如何设计这个父类，抽象出公共特性。

&nbsp;

## 类基础

常规的书写规范是把类定义和类实现放在分开的`.h`头文件和`.cpp`源文件中。

>  类定义放在一个头文件中，多个`.cpp`文件都包含这个头文件，那不就相当于这个类定义了多次吗？
>
> 类是一个特殊的存在，在多个不同的`.cpp`源文件中用`#include`重复类定义是被系统允许的。所以许多人把类定义也称为“类声明”。

&nbsp;

## explicit与初始化列表

### 隐式转换和explicit

```cpp
class Time
{
public:
	Time()
	{
		Hour = 12;
		Minute = 59;
		Second = 59;
	}
	Time(int tmphour, int tmpmin, int tmpsec)
	{
		Hour = tmphour;
		Minute = tmpmin;
		Second = tmpsec;
	}
private:
	int Hour;
	int Minute;
	int Second;
};
```

编译系统其实背着开发者在私下里还是做了很多事情的，这里谈一谈单参数的构造函数带来的隐式转换。如下两个对象定义和初始化，会出现语法错误：

```cpp
	Time myTime23 = 14;		// 现在语法错
	Time myTime24 = (12, 13, 14, 15, 16);	// 现在语法错，不管()中有几个数字
```

但是在Time类中增加了单参数的构造函数时，可以发现上面两种定义对象的方式不再出现语法错误，而且每一个对象在定义和初始化时，都调用了单参数构造函数（尤其是括号里有很多数字的，只有最后一个数字作为参数传递到单参数构造函数中去了）。

上面的代码把一个14给了myTime23，而myTime23是一个对象，14是一个数字，那么说明编译系统应该是有一个行为，把14这个参数类型转换成了Time类类型，这种转换称为隐式类型转换或简称隐式转换。

&nbsp;

现在再来写一个普通函数，它的形参类型就是Time类类型：

```cpp
void func(Time myt)
{
	return;
}
```

现在可以发现，用一个数字就能调用`func`函数：

```cpp
	func(16);	// 这里依旧调用了Time类的单参数的构造函数
```

这说明系统进行了一个从数字16到对象`myt`的一个转换，产生了一个`myt`对象（临时对象），函数调用完毕后，对象`myt`的声明周期结束，所占用的资源被系统回收。

```cpp
	myTime23 = 16;	// 这句也调用了Time类的单参数构造函数，生成了一个临时对象，然后把临时对象的值复制到了myTime23的成员变量去了
```

&nbsp;

上面这种隐式转换让人糊涂，是否可以强制系统，明确要求构造函数不能做隐式转换呢？

可以。如果构造函数声明中带有explicit（显示），则这个构造函数只能用于初始化和显示类型转换。

&nbsp;

我们把之前带有3个参数的Time构造函数的声明前面加上explicit

```
	explicit Time(int tmphour, int tmpmin, int tmpsec);
```

此时，编译项目，发现如下这行代码出现语法错误：

![image-20211010232026985](C:\Users\whh\AppData\Roaming\Typora\typora-user-images\image-20211010232026985.png)

但是，下面这行少了个“=”，却能够成功创建对象。

```cpp
Time myTime(12, 13, 52);		// 能够成功创建对象
```

这说明有了这个等号，就变成了一个隐式初始化（其实是构造并初始化），省略了这个等号，就变成了显示初始化（也叫直接初始化）。

&nbsp;

建议：一般来说，单参数的构造函数都声明为explicit，除非有特别的原因。当然，explicit也可以用于无参数或者多个参数的构造函数中。拷贝构造函数，一般都不声明为explicit。

&nbsp;

### 构造函数初始化列表

```cpp
	Time(int tmphour, int tmpmin, int tmpsec) :Hour(tmphour), Minute(tmpmin), Second(tmpsec) {}
	// 这就叫构造函数初始化列表
```

在调用构造函数的同时，可以初始化成员变量的值，初始化列表的执行是在函数体执行之前就执行了的。

对于初始化列表，成员变量的给值顺序并不是依据初始化列表的从左至右的顺序，而是依据类定义中成员变量的定义顺序（从上到下的顺序）。

&nbsp;

提倡优先考虑使用构造函数初始化列表，原因如下：

1. 构造函数初始化列表写法显得更专业，有人会通过此来鉴别程序员的水平。
2. 一种写法叫作初始化，一种写法叫作复制，叫法不同。
   1. 对于内置类型如`int`类型的成员变量，使用构造函数初始化列表来初始化和使用赋值语句来初始化其实差别不大。
   2. 但是对于类类型的成员变量，使用初始化列表的方式初始化比使用赋值语句初始化效率更高（因为少调用了一次甚至几次该成员变量相关类的各种特殊成员函数，如构造函数等）。

&nbsp;

## inline、const、mutable、this与static

### 在类定义中实现成员函数inline

直接在类的定义中实现的成员函数会被当作inline内联函数来处理。

&nbsp;

### 成员函数末尾的const

在成员函数末尾加`const`，作用是告诉系统，这个成员函数不会修改该对象里面的任何成员变量的值等。也就是说，这个成员函数不会修改类对象的任何状态。

这种在末尾缀了一个`const`的成员函数也称为“常量成员函数”。

&nbsp;

### mutable

mutable表示不稳定的、容易改变的意思，mutable的引入也正是为了突破const的限制。

在末尾有const修饰的成员函数中，是不允许修改成员变量值的。那在设计类成员变量的时候，假设确实遇到了需要在const结尾的成员函数中希望修改成员变量的值的需求，怎么办呢？

也许有人会说，那就把函数末尾的const去掉，变成一个不以const结尾的成员函数。但是这个时候会遇到一个新的问题——如果这个成员函数从const变成非const了，那么就不能被const对象调用了。

所以引入了mutable修饰符来修饰一个成员变量。一个成员变量一旦被mutable所修饰，就表示这个成员变量永远处于可变状态，即使是在以const结尾的成员函数中。

&nbsp;

### this

调用成员函数时，编译器负责把调用这个成员函数的对象的地址传递给这个成员函数中一个隐藏的this形参中。即this表示的是指向本对象的指针。

这也解释了为什么在成员函数体中可以直接使用成员变量，就是因为从系统的角度来看，任何对类成员的直接访问都被看做通过this做隐式调用。

其实，this本身是一个指针常量，总是指向这个对象本身，不可以让this再指向其他地方。

在const成员函数中，this指针是一个指向const对象的const指针，例如，类类型为Time，那么this就是`const Time* const`类型。

&nbsp;

### static成员

static成员变量/函数的特点是：不属于某个对象，而是属于整个类，被类的所有对象所共享。

在static成员函数中，只能操作static成员变量，不能操作非static成员变量。

```cpp
public:
	static int mystatic;		// 声明静态成员变量但没有定义
	static void mstafunc(int testvalue);	// 声明静态成员函数
```

普通成员变量在定义一个类对象时，就已经被分配内存了。那静态成员变量什么时候分配内存呢？

上面的`static int mystatic;`这行代码是对静态成员变量的声明，这代表着还没有给该静态成员变量分配内存，这个静态成员变量还不能使用。为了能够使用，必须定义这个静态成员变量，也就是给静态成员变量分配内存。

&nbsp;

一般会在某一个`.cpp`源文件的开头来定义这个静态成员函数，这样能够保证在调用任何函数之前这个静态成员变量已经被成功初始化，从而保证这个静态成员变量能够被正常使用。

在MyProject.cpp最上面写如下代码：

```cpp
int Time::mystatic = 5;		// 可以不给初值，则系统默认会给0，定义时这里无须用static
```

&nbsp;

## 类内初始化、“=default;”和“=delete;”

### 类内初始值

在c++11新标准里，可以为成员变量提供一个类内的初始值，那么在创建对象的时候，这个初始值就用来初始化该成员变量。

对于没有初始化值的成员变量，系统有默认的初始策略，如整型成员变量，系统会随便扔个值进去。

在Time类内部，修改一下成员变量Second的定义：

```cpp
int Second{0};		// 或者 int Second = 0;  两种写法都可以
```

&nbsp;

### const成员变量的初始化

对于类的const成员，只能使用初始化列表来初始化，而不能在构造函数内部进行赋值操作。

&nbsp;

### “=default;"和”和“=delete;”

在C++11中，引入了两种新的写法”=default;“和”=delete;"。

```cpp
Time() = default;
```

这样写了之后，Time默认构造函数就带有了“=default”特性——编译器能够为这种函数自动生成函数体（等价于空函数体”{}“）。

一般这种“=default”写法只适合一些比较特殊的函数，如默认构造函数（不带参数），普通成员函数就不能这样写。

&nbsp;

"=delete"这个写法时用来让程序员显示地禁用某个函数而引入的，可用于任何函数，不仅仅局限于类的成员函数。

&nbsp;

## 几个话题

### 构造函数的成员初始化效率问题

前面已经提到，对于基本数据类型的成员变量，无论是通过初始化列表的方式给值，还是通过赋值的方式给值，对于系统来讲，所执行的代码几乎没差别。

但是，对于类类型的成员变量，使用初始化列表的方式初始化比使用赋值语句初始化效率更高。为什么？

我们来看如下例子

```cpp
class Test
{
public:
	Test(int i = 0)
	{
		cout << "Test构造函数调用" << endl;
	}

private:
	int test;
};
class Time
{
public:
	Time() = default;
	Time(int tmphour, int tmpmin, int tmpsec):Hour(tmphour),Minute(tmpmin),Second(tmpsec)
	{
		cout << "Time构造函数调用" << endl;
	}
private:
	int Hour;
	int Minute;
	int Second;
	Test test;
};
```

当用诸如`Time myTime(1, 2, 3);`这行代码生成一个Time类型对象的时候，显然，这会调用Time类带三个参数的构造函数，但是因为Time类中有一个类类型变量`Test test;`的存在，通过调式允许可以发现，在执行Time类的带三个参数的构造函数的初始化列表的那个时刻，**系统会给一次构造类类型对象test的机会**。

![image-20211015111131794](C:\Users\whh\AppData\Roaming\Typora\typora-user-images\image-20211015111131794.png)

即我们无论是否在初始化列表中构造test对象，系统都会给一次构造类类型对象test的机会。所以如果我们如果想要初始化Time的成员变量test，那就绝对不应该放过这次机会，直接在初始化列表中构造类类型对象。

&nbsp;

但是我们如果像下面这样写代码：

```cpp
	Time::Time(int tmphour, int tmpmin, int tmpsec):Hour(tmphour),Minute(tmpmin),Second(tmpsec)
	{
		test = 100;
	}
```

这样不仅浪费了系统给的那次构造类类型对象的机会，而且还会导致Test类的构造函数、operator=、析构函数分别被执行了一次，极大浪费了效率。

&nbsp;

### 析构函数的成员销毁

1. 当释放一个对象的时候，首先执行该对象所属类的函数体，执行完毕后，该对象就被销毁，此时对象中的各种成员变量也会被销毁。
2. 成员变量初始化的时候是在类中先定义的成员变量先进行初始化，销毁的时候是先定义的成员变量后销毁。

&nbsp;



