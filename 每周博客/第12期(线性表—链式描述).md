@[TOC](目录)

## 线性表—链式描述

在基于数组的描述中，元素的地址是由数学公式决定的，分布在一段连续的内存空间中。

在链式描述中，线性表的元素在内存中的存储位置是随机的。每个元素都有一个明确的指针或链指向线性表的下一个元素的地址 。

&nbsp;

## 单向链表

设L = ($e_0$, $e_1$,..., $e_n-_1$) 是一个线性表，在这个线性表中，每个元素都在一个单独的节点中描述，每一个节点都有一个链域，它的值是线性表的下一个元素的地址。所以，元素$e_i$的节点链接着元素$e_i+_1$的节点，`0 <= i < n-1`，元素$e_n-_1$的节点没有其他节点可链接，因此链域的值为`NULL`。

变量`firstNode`用来指向链式描述的第1个节点，一般来说，为了找到索引为`theIndex`的元素，需要从`firstNode`开始，跟踪`theIndex`个指针才能找到。

![image-20210905162135361](C:\Users\whh\AppData\Roaming\Typora\typora-user-images\image-20210905162135361.png)

如上图每一个节点只有一个链，这种结构称为单向链表（singly linked list）。链表从左到右，每一个节点（最后一个节点除外）都链接着下一个节点，最后一个节点的链域值为`NULL`。这样的结构也称为链条（chain）。

&nbsp;

## 结构 chainNode

为了用链表描述线性表，我们要定义一个结构`chainNode`和一个类`chain`。

```cpp
template<class T>
struct chainNode
{
	// 数据成员
	T element;						// 节点的数据域，存储表元素
	chainNode<T>* next;				// 节点的链域，存储下一个节点的指针

	// 方法
	chainNode() {}
	chainNode(const T& element)
	{
		this->element = element;
	}
	chainNode(const T& element, chainNode<T>* next)
	{
		this->element = element;
		this->next = next;
	}
};
```

&nbsp;

## 类 chain

```cpp
template<class T>
class chain : public linearList<T>
{
public:
	// 构造函数、复制构造函数和析构函数
	chain(int initialCapacity = 10);
	chain(const chain<T>&);
	~chain();

	// 抽象数据类型ADT的方法
	bool empty() const { return listSize == 0; }
	int size() const { return listSize; }
	T& get(int theIndex) const;
	int indexOf(const T& theElement) const;
	void erase(int theIndex);
	void insert(int theIndex, const T& theElement);
	void output(ostream& out) const;
protected:
	void checkIndex(int theIndex)const;  // 如果索引无效，抛出异常
	chainNode<T>* fitstNdoe;		// 指向链表第一个节点的指针
	int listSize;			// 线性表的元素个数
};
```

数据成员是`firstNode`和`listSize`。`firstNode`是指向首元素节点的指针。当链表为空时，`firstNode`的值为`NULL`，`listSize`表示线性表的元素个数，它等于链表的节点数。

&nbsp;

### 构造函数和复制构造函数

```cpp
template<class T>
chain<T>::chain(int initialCapacity)
{// 构造函数
	if (initialCapacity < 1)
	{
		ostringstream s;
		s << "Initial capacity = " << initialCapacity << " Must be > 0";
		throw illegalParameterValue(s.str());
	}
	firstNode = NULL;
	listSize = 0;
}

template<class T>
chain<T>::chain(const chain<T>& theList)
{// 复制构造函数
	listSize = theList.listSize;
	
	if (listSize == 0)
	{
		firstNode = NULL;
		return;
	}
	// 链表theList 非空
	chainNode<T>* sourceNode = theList.firstNode;        // 要复制链表theList的节点
	firstNode = new chainNode<T>(sourceNode->element);   // 复制链表theList的首元素
	sourceNode = sourceNode->next;
	chainNode<T>* targetNode = firstNode;        // 当前链表*this的最后一个节点
	while (sourceNode != NULL)
	{// 复制剩余元素
		targetNode->next = new chainNode<T>(sourceNode->element);
		targetNode = targetNode->next;
		sourceNode = sourceNode->next;
	}
	targetNode->next = NULL; // 链表结束
}
```

为了创建一个空链表，只需令第一个节点指针`firstNode`的值为`NULL`，与数组描述的线性表不同，链表在创建时不需要估计元素的最大个数以分配初始空间。不过，构造函数还是具有一个表示初始容量的形参`initialCapacity`，目的是与类`arrayList`相容。

&nbsp;

### 析构函数

```cpp
template<class T>
chain<T>::~chain()
{// 链表析构函数，删除链表的所有节点。
	while (firstNode != NULL)
	{// 删除首节点
		chainNode<T>* nextNode = firstNode->next;
		delete firstNode;
		firstNode = nextNode;
	}	
}
```

&nbsp;

### 方法get

```cpp
template<class T>
T& chain<T>::get(int theIndex) const
{// 返回索引为theIndex的元素，若该元素不存在，则抛出异常
	checkIndex(theIndex);

	// 移向所需要的节点
	chainNode<T>* currentNode = firstNode;
	for (int i = 0; i < theIndex; i++)
		currentNode = currentNode->next;

	return currentNode->element;
}
```

在数组描述的线性表中，我们根据公式来计算一个表元素的位置。

然而在链表中，要寻找索引为`theIndex`的元素，必须从第一个节点开始，跟踪链域`next`知道找到所需要的元素节点指针，也就是说，必须跟踪`theIndex`个指针。

&nbsp;

### 方法 indexOf

```cpp
template<class T>
int chain<T>::indexOf(const T& theElement) const
{// 返回元素theElement首次出现时的索引，若该元素不存在，则返回-1
	chainNode<T>* currentNode = firstNode;
	int index = 0;       // 当前节点的索引
	while (currentNode != NULL && currentNode->element != theElement)
	{
		currentNode = currentNode->next;    // 移向下一个元素
		index++;
	}
	// 确定是否找到所需的元素
	if (currentNode == NULL)
		return -1;
	return index;
}
```

&nbsp;

### 方法 erase

方法`erase`删除索引为`theIndex`的元素，需要考虑三种情况：

1. `theIndex < 0`或者`theIndex >= listSize`。这时，删除操作无效，因为没有这个位置上的元素。这种情况可能表示链表为空。
2. 删除非空表的第0个元素节点。
3. 删除其他元素节点。

```cpp
template<class T>
void chain<T>::erase(int theIndex)
{// 删除索引为theIndex的元素。若该元素不存在，则抛出异常
	checkIndex(theIndex);

	// 索引有效，找到需要删除的元素节点
	chainNode<T>* deleteNode;
	if (theIndex == 0)
	{// 删除链表的首节点
		deleteNode = firstNode;
		firstNode = firstNode->next;
	}
	else
	{// 用指针p指向要删除节点的前驱节点
		chainNode<T>* p = firstNode;
		for (int i = 0; i < theIndex - 1; i++)
			p = p->next;

		deleteNode = p->next;        // 删除deleteNode指向的节点
		p->next = p->next->next;
	}
	listSize--;
	delete deleteNode;
}
```

&nbsp;

### 方法insert

为了在链表中索引为`theIndex`的位置上插入一个新元素，首先需要找到索引为`theIndex - 1`的元素节点，然后在该节点之后插入新元素节点。

```cpp
template<class T>
void chain<T>::insert(int theIndex, const T& theElement)
{// 在索引为theIndex的位置上插入元素theElement
	if (theIndex < 0 || theIndex > listSize)
	{// 无效索引
		ostringstream s;
		s << "index = " << theIndex << " size = " << listSize;
		throw illegalParameterValue(s.str());
	}

	if (theIndex == 0)
		firstNode = new chainNode<T>(theElement, firstNode);   // 在链表头插入
	else
	{
		// 寻炸新元素的前驱
		chainNode<T>* p = firstNode;
		for (int i = 0; i < theIndex - 1; i++)
			p = p->next;
		// 在p之后插入
		p->next = new chainNode<T>(theElement, p->next);
	}
	listSize++;
}
```

&nbsp;

### 输出链表

```cpp
template<class T>
void chain<T>::output(ostream& out) const
{// 把链表放入输出流
	for (chainNode<T>* currentNode = firstNode; currentNode != NULL; currentNode = currentNode->next)
		out << currentNode->element << " ";
}

template<class T>
ostream& operator<<(ostream& out, const chain<T>& x)
{// 重载<<
	x.output(out);
	return out;
}
```

