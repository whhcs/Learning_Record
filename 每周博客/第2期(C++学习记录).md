## 0.头文件中的防卫式声明

```C++
# ifndef  __COMPLEX__
# define __COMPLEX__
class complex
{

}
# endif
```

防止头文件的内容被多次包含



## 1.inline内联函数

```C++
inline double imag(const complex &x)
{
    return x.imag();
}
```

1. 在C/C++中，为了解决一些频繁调用的小函数大量消耗栈空间的问题，特别的引入了inline修饰符，表示为内联函数
2. 函数若在class body内定义完成，便自动成为inline候选人若在类内声明，类外定义，想要成为内联函数，则在类外要加上inline，否则就认为不是内联的



## 2.构造函数初始化

``` C++
class complex
{
public:
	complex(double r = 0, double i = 0) :re(r), im(i) {}
private:
	double re, im;
};
```

在初始化列表中，才是对成员变量的初始化。而函数体内，叫做赋值。初始化列表比赋值效率更高。



## 3.常量成员函数

```C++
double real()const { return re; }
double imag()const { return im; }
```

不会改变类属性的成员函数，全部加上`const`说明，既然函数不会改变对象，那么就如实说明，编译器能帮你确保函数的`const`属性，阅读代码的人也能明确你的意图。而且若没有加`const`关键字，那么`const`对象调用该函数时，则会报错。`const`对象只能调用常量成员函数。



## 4.值传递VS引用传递

```C++
complex& operator+=(const complex&);
```

1. 函数参数传递，如果不需要改变参数值，建议使用`const`的引用来减小开销。
2. 使用引用避免类对象构造与析构的开销，使用`const`确保参数不会被改变。内置类型的值传递与引用传递效率没有多大差别，甚至值传递效率会更高。例如，传递`char`类型时，值传递只需传递一个字节；引用实际上是指针实现，需要四个字节（32位机）的传递开销。但是为了一致，不妨统一使用引用。



```C++
inline complex& _doapl(complex* ths, const complex& r)
{
	ths->re += r.re;
	ths->im += r.im;
	return *ths;
}
inline complex& complex::operator+=(const complex& r)
{
	return _doapl(this, r);
}
```

1. 如果可以，函数的返回值也尽量使用引用。要放回的变量要有一定限制：**该变量的在进入函数前，已经被分配了内存**。以此条件来考量，很容易决定是否要返回引用。而在函数被调用时才创建出来的对象，一定不能返回引用。

2. 注意不要返回局部变量的引用，以引用方式返回函数局部变量会引发程序未定义行为，离开函数作用域局部变量被销毁，引用该变量没有意义。

## 5.友元

```C++
double complex::fun(const complex&a)
{
    return a.re+a.im;
}
```

相同`class`的各个`object`互为`friend`，可以通过彼此的内部方法调用传入参数的私有成员变量



## 6.小细节

以前也总是注意到书中类声明时，通常把public放在private前面。

而我习惯把private看前面，因为这样在写成员函数的时候，可以看到前面的变量。

虽然并没有对错之分，但是将提供给外界使用的接口，放在类声明的最前面，使得类用户一眼就能看见接口，也算是一个不错的好习惯

