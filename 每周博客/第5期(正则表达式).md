# 正则表达式

@[TOC](目录)
&nbsp;

## 定义

正则表达式是对字符串操作的一种逻辑公式，我们一般使用正则表达式对字符串进行匹配和过滤。例如，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

正则表达式是由普通字符和元字符组成。
&nbsp;
正则表达式中常见的特殊字符有以下几个：
`.+?*$[]()^{}\`
如果要在正则表达式中表示这几个字符本身，就应该在字符前面加上`\`。
&nbsp;

## 常用元字符:

    .                     匹配除换行符以外的任意字符
    \w                    匹配数字、字母、下划线，汉字
    \s                    匹配任意的一个空白符，如空格，\t,\r,\n等
    \d                    匹配任意的一个数字，等价于[0-9]
    \n                    匹配一个换行符
    \t                    匹配一个制表符
    ^                     匹配字符串的开始
    $                     匹配字符串的结尾
    \W                    匹配非(字母、数字、下划线、汉字)
    \D                    匹配一个非数字，等价于[^\d],[^0-9]
    \S                    匹配非空白符
    a|b                   匹配a或b
    ()                    匹配括号内的表达式，也表示一个组
    [...]                 匹配字符组中的其中一个字符
    [^...]                匹配一个除了字符组中出现的字符

&nbsp;

## 量词

想要一次性匹配多个字符，则需要使用到量词

```
*                     表示左边的字符可重复零次或更多次
+                     表示左边的字符可重复一次或更多次
？                    表示左边的字符可重复零次或一次
{n}                   n为整数，表示左边的字符必须且只能重复n次
{n,}                  表示左边的字符最少重复n次或更多次
{n,m}                 表示左边的字符至少重复n次，最多重复m次
```

&nbsp;

### 量词的用法
```
'.+'                    匹配任意长度不为0且不含'\n'的字符串。'+'表示左边的'.'代表的任意字符出现一次或更多次。不要求出现的字符都必须一样。
'.*'                    匹配任意不含'\n'的字符串，包括空串。
'[\dac]+'               匹配长度不为0且由数字或'a','c'构成的串，如'451a'，'a21c78ca'。
'\w{5}'                 匹配长度为5的由数字、字母、下划线、汉字构成的串，如'高大abc'，'33我a1'。
```

&nbsp;

## 惰性匹配和贪婪匹配

在量词中的`?`,`*`,`+`,`{}`都属于贪婪匹配，就是尽可能多的匹配到结果。
 在使用`.*`后面如果加了`?`，这是尽可能的少匹配。表示惰性匹配。`.?`，`.+`，`.{}`类似

&nbsp;

## python中的re模块

### 正则表达式中的函数



#### 判断一句话中是否有数字

1. `re.search(pattern, string, flags = 0)`

   ```python
   res = re.search("\d+", "我今年18岁了，体重为60kg")
   # 输出子串及起止位置
   print(res.group(), res.span())  # 18 (3, 5)
   ```
   - 查找字符串中可以匹配成功的子串，匹配到第一个结果就返回。不会匹配出多个结果。
   - 成功则返回一个匹配对象，否则返回None

   &nbsp;

2. `re.findall(pattern, string, flags = 0)`

   ```python
   list = re.findall("\d+", "我今年18岁了，体重为60kg")
   print(list)  #['18', '60']
   ```

   - 查找字符串中所有和模式匹配的子串(不重叠)放入列表。一个子串都找不到就返回空表[]。

   &nbsp;

3. `re.match(pattern, string, flags = 0)`

   ```python
   result = re.match("\d+","18岁了，我喜欢5个明星")
   print(result.group()) # 18，result.group()是匹配到的字符串
   ```

   - 从字符串string的起始位置开始匹配一个模式pattern(即默认加了^)，匹配到第一个结果就返回。 （一般用于匹配手机号，邮箱号）
   - 成功则返回一个匹配对象，否则返回None
   - flags 标志位，用于控制模式串的匹配方式，如：是否区分大小写，多行匹配等等。如: `re.M | re.I`表示忽略大小写，且多行匹配。

   &nbsp;

4. `re.finditer(pattern, string, flags = 0)`

   ```python
   it = re.finditer("\d+", "我今年18岁了，体重为60kg")
   for item in it:
       print(item.group(), item.span())    # 18 (3, 5)     60 (11, 13)
   ```

   - 查找字符串中所有和模式匹配的子串(不重叠)，每个子串对应于一个匹配对象，返回匹配对象的迭代器。（一般用于爬虫）

&nbsp;

#### 其他操作

1. `split`分割

   ```python
   ret = re.split('[ab]', 'qwerafjbcd')   
   #先按'a'分割，得到'qwer'和'fjbcd'，再对'qwer'和'fjbcd'分别按'b'分割
   print(ret)          #['qwer', 'fj', 'cd']
   ```
&nbsp;
2. `re.sub(pattern, repl, string, count=0, flags=0)`

   用于替换匹配的字符串,比`str.replace`功能更加强大

   ```python
   ret = re.sub('[a-z]+','sb','武配齐是abc123',)
   print(ret) #武配齐是sb123
   re.sub('\d+','|', 'alex22wupeiqi33oldboy55',count=2) 
   print(ret) #alex|wupeiqi|oldboy55
   ```
&nbsp;
3. `compiler`

   ```python
   obj = re.compile(r'\d{3}')  #将正则表达式编译成为一个 正则表达式对象，规则要匹配的是3个数字
   
   obj = re.compile(r'\d+') # 先加载这个正则，后面可以直接用这个正则去匹配内容
   lst = obj.findall("我今天吃了3个馒头，喝了2碗粥")
   print(lst)   # ['3', '2']
   ```
   &nbsp;
   ### 爬虫必会的一个重点

   - ()括起来的内容是你最终想要的结果
   - (?P<name>正则) 把正则匹配到的内容直接放在name组里面，后面取数据的时候直接group(name)

   ```python
   obj = re.compile(r"今天吃了(?P<mian>\d+)碗面，又吃了(?P<xian>\d+)盘小咸菜")
   result = obj.finditer("明天我要吃4碗面，喝上8碗汤。今天吃了5碗面，又吃了6盘小咸菜，昨天吃了1碗面条")
   for item in result:
       print(item.group("mian"))       # 5
       print(item.group("xian"))       # 6
       print(item.groupdict())         # {'mian': '5', 'xian': '6'}
   ```